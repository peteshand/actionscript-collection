package Actionscript.data{	import flash.events.EventDispatcher;		/**	 * DataProvider	 * 	 * @author Rich Perez	 * 	 * !TODO: Add support for events dispatched.	 */	public class DataProvider extends EventDispatcher	{		private var _items:Array;				/**		 * Creates a new DataProvider object using a XML instance or		 * an array of data objects as the data source.		 * 		 * @param	value		 */		public function DataProvider(value:Object = null) 		{			this._items = [];						if (value)			{				if (value is XML)				{					for each (var o:XML in value[0].*)					{						this.addItem(o);					}				}				else if (value is Array)				{					this.addItems(value);				}				else				{					throw new Error("DataProvider only supports an XML object and Array.");				}			}		}			//		// accessors		//				/**		 * The number of items that the data provider contains.		 */		public function get length():uint		{			return this._items.length;		}				//		// public functions		//				/**		 * Appends an item to the end of the data provider.		 * 		 * @param	item		 * 		The item to be added to the DataProvider object.		 */		public function addItem(item:Object):void		{			this._items.push(item);		}				/**		 * Adds a new item to the data provider at the specified index. 		 * If the index that is specified exceeds the length of the 		 * data provider, the index is ignored.		 * 		 * @param	item 		 * 		The item to be added to the DataProvider object.		 * 		 * @param	index		 * 		The index in the DataProvider to add the item.		 */		public function addItemAt(item:Object, index:uint):void		{			this._items.splice(index, 0, item);		}				/**		 * Appends multiple items to the end of the DataProvider and dispatches		 * a DataChangeType.ADD event. The items are added in the order in 		 * which they are specified.		 * 		 * @param	items		 * 		The items to be added to the DataProvider.		 */		public function addItems(items:Object):void		{			if (items is Array)			{				if (this._items.length > 0)					this._items.concat(items);				else this._items = items as Array;			}			else			{				throw new Error("DataProvider.addItems() current only supports Arrays.");			}		}				/**		 * Adds several items to the data provider at the specified index and 		 * dispatches a DataChangeType.ADD event.		 * 		 * @param	items		 * 		The items to be added to the DataProvider.		 * 		 * @param	index 		 * 		The index in the DataProvider to add the items.		 */		public function addItemsAt(items:Object, index:uint):void		{			this._items.splice(index, 0, items);		}				/**		 * Creates a copy of the current DataProvider object.		 * 		 * @return DataProvider		 * 		 */		public function clone():DataProvider		{			return new DataProvider(this._items);		}				/**		 * Concatenates the specified items to the end of the current		 * data provider. This method dispatches a DataChangeType.ADD event.		 * 		 * @param	items 		 * 		The items to be added to the DataProvider.		 */		public function concat(items:Object):void		{			this.addItems(items);		}				/**		 * Returns the item at the specified index.		 * 		 * @param	index		 * 	Location of the item to be returned.		 * 		 * @return 	Object		 */		public function getItemAt(index:uint):Object		{			return this._items[index];		}				/**		 * Returns the item at the specified index.		 * 		 * @param	item		 * 		The item to be located.		 * @return		 * 		The index of the specified item, or -1 if the specified item is not found.		 */		public function getItemIndex(item:Object):int		{			var index:int = -1;			for (var i:int = 0; i < length; i++)			{				if (this._items[i] === item)				{					index = i;					break;				}			}			return index;		}				/**		 * Invalidates all the data items that the DataProvider contains and dispatches a		 * DataChangeEvent.INVALIDATE_ALL event. Items are invalidated after they are changed;		 * the DataProvider automatically redraws the invalidated items.		 */		public function invalidate():void		{			this._items = this._items.slice();		}				/**		 * Invalidates the specified item. An item is invalidated after it is changed;		 * the DataProvider automatically redraws the invalidated item.		 * 		 * @param	item		 * 		Item to be invalidated.		 */		public function invalidateItem(item:Object):void		{			var index:int = this.getItemIndex(item);			this._items[index] = item;		}				/**		 * Invalidates the item at the specified index. An item is invalidated after 		 * it is changed; the DataProvider automatically redraws the invalidated item.		 * 		 * @param	index		 * 		Index of the item to be invalidated.		 */		public function invalidateItemAt(index:uint):void		{			this._items[index] = this._items[index]		}				/**		 * Appends the specified data into the data that the data provider contains and 		 * removes any duplicate items. This method dispatches a DataChangeType.ADD event.		 * 		 * @param	newData  		 * 		Data to be merged into the data provider.		 */		public function merge(newData:Object):void		{			this._merge(newData);		}				/**		 * Removes all items from the data provider and dispatches a DataChangeType.REMOVE_ALL event.		 */		public function removeAll():void		{			this._items = [];		}				/**		 * Removes the specified item from the data provider and dispatches a DataChangeType.REMOVE event.		 * 		 * @param	item		 * 		The item to be removed from the DataProvider.		 * 		 * @return 		 */		public function removeItem(item:Object):Object		{			var index:int = this.getItemIndex(item);			return this.removeItemAt(index);		}				/**		 * Removes the item at the specified index and dispatches a DataChangeType.REMOVE event.		 * 		 * @param	index		 * 		 Index of the item to be removed.		 * 		 * @return		 */		public function removeItemAt(index:uint):Object		{			return this._items.splice(index, 1)[0];		}				/**		 * Replaces an existing item with a new item and dispatches a DataChangeType.REPLACE event.		 * 		 * @param	newItem		 * 		The item to be replaced.		 * 		 * @param	oldItem		 * 		The replacement item.		 * 		 * @return		 * 		The item that was replaced.		 */		public function replaceItem(newItem:Object, oldItem:Object):Object		{			var index:int = this.getItemIndex(newItem);			this._items[index] = oldItem;						return newItem;		}				/**		 * Replaces the item at the specified index and dispatches a DataChangeType.REPLACE event.		 * 		 * @param	newItem		 * 		 The replacement item.		 * 		 * @param	index		 * 		The index of the item to be replaced.		 * 		 * @return		 * 		The item that was replaced.		 */		public function replaceItemAt(newItem:Object, index:uint):Object		{			var oldItem:Object = this._items[index];			this._items[index] = newItem;						return oldItem;		}				/**		 * Sorts the items that the data provider contains and dispatches a DataChangeType.SORT event.		 * 		 * @param	...sortArgs		 *  	The arguments to use for sorting.		 * 		 * @return		 */		public function sort(...sortArgs):*		{			return this._items.sort(sortArgs);		}				/**		 * Sorts the items that the data provider contains by the specified field and dispatches 		 * a DataChangeType.SORT event. The specified field can be a string, or an array of string 		 * values that designate multiple fields to sort on in order of precedence.		 * 		 * @param	fieldName		 * 		The item field by which to sort. This value can be a string or an array of string values.		 * 		 * @param	options		 * 		Options for sorting.		 * 		 * @return		 */		public function sortOn(fieldName:Object, options:Object = null):*		{			return this._items.sortOn(fieldName, options);		}				/**		 * Creates an Array object representation of the data that the data provider contains.		 * 		 * @return		 */		public function toArray():Array		{			return this._items.slice();		}				/**		 * Creates a string representation of the data that the data provider contains.		 * 		 * @return		 */		override public function toString():String		{						return this._items.toString();		}				//		// private functions		//				/**		 *  @private		 */		private function _merge(newData:Object):void		{			if (newData is Object)			{				for (var i:int = 0; i < this.length; i++)				{					if (this._items[i] === newData) this.removeItemAt(i);				}							}			else if (newData is Array)			{				for (var j:int = 0; j < this.length; j++)				{					for (var k:int = 0; k < newData.length; k++)					{						if (this._items[j] === newData[k]) this.removeItemAt(j);					}				}			}						this.concat(newData);		}	}}